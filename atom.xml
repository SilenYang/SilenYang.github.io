<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SilenYang@前端笔记</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-10-13T07:24:16.107Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>SilenYang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数组的遍历</title>
    <link href="http://yoursite.com/2017/10/11/%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <id>http://yoursite.com/2017/10/11/数组的遍历/</id>
    <published>2017-10-11T08:57:27.000Z</published>
    <updated>2017-10-13T07:24:16.107Z</updated>
    
    <content type="html"><![CDATA[<p>在平常的开发中，对数组这一数据结构的操作我们是避免不了的，对它的增、删、改、查等操作可以说是经常性的。在这些操作中，对数组的遍历可以说是再普通不过的事情了。然而就这一普通的操作也有很多的方法，平常我们用的也就那么一两种。</p><p>为了更好的让我们记忆和选择这些方法来帮助我们提高开发效率，今天就把这些方法统一的罗列出来，方便以后查阅。</p><a id="more"></a><h3 id="for-…"><a href="#for-…" class="headerlink" title="for ( ; ; ) { … }"></a>for ( ; ; ) { … }</h3><p>这是最传统的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const arr=[1,2,3];</div><div class="line">for(let i=0;i&lt;arr.length;i++)&#123;</div><div class="line">    console.log(arr[i]);</div><div class="line">&#125;</div><div class="line">// 输出</div><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td></tr></table></figure><h3 id="for-…-in"><a href="#for-…-in" class="headerlink" title="for … in"></a>for … in</h3><p>语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for(variable in object)</div><div class="line">statement</div></pre></td></tr></table></figure><p>variable是声明一个变量的语句，在循环体内部，对象的一个属性名会被作为字符串赋给变量variable。数组也是一种特殊的Object。</p><p>该方法不仅可以遍历数组，还可以遍历对象。对象的有些属性标记成了只读的，永久的（不可删除的）或者不可枚举的，这些属性使用 <strong>for/in</strong> 循环不能枚举出来。虽然所有的用户定义的属性都可以枚举，但是许多内部属性，包括所有的内部方法都是不可枚举的。另外对象可以继承其他对象的属性，那些已继承的用户定义的属性可以使用 <strong>for/in</strong> 循环枚举出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const arr=[1,2,3];</div><div class="line">for(let i in arr)&#123;</div><div class="line">    console.log(arr[i]);</div><div class="line">&#125;</div><div class="line">// 输出</div><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td></tr></table></figure><p><code>for ... in</code> 方法只能遍历出对象可枚举的属性，判断对象的属性是否是可枚举的可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable" target="_blank" rel="external">Object.propertyIsEnumerable()</a> 来判断。该方法返回一个布尔值，表明指定的属性名是否是当前对象可枚举的自身属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const obj = &#123;prop: 123&#125;;</div><div class="line">obj.propertyIsEnumerable(&apos;prop&apos;) // true</div></pre></td></tr></table></figure><p>要修改一个对象属性的可枚举等属性需要用到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="external">Object.defineProperty(obj, prop, descriptor)</a> 方法。</p><h3 id="for-…-of"><a href="#for-…-of" class="headerlink" title="for … of"></a>for … of</h3><p>遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。<code>Map</code>,<code>Set</code>结构无下标，无法使用索引进行遍历。为了统一集合类型，ES6标准引入了新的iterable类型。</p><p><code>Array</code>、<code>Map</code>和<code>Set</code>都属于iterable类型。具有iterable类型的集合可以通过新的<code>for … of</code>循环来遍历。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const arr=[1,2,3];</div><div class="line">for(let i of arr)&#123;</div><div class="line">    console.log(i);</div><div class="line">&#125;</div><div class="line">// 输出</div><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td></tr></table></figure><h4 id="for-…-of循环和for-…-in循环有何区别"><a href="#for-…-of循环和for-…-in循环有何区别" class="headerlink" title="for … of循环和for … in循环有何区别"></a>for … of循环和for … in循环有何区别</h4><p><code>for … in</code>循环，它遍历的实际上是对象的属性名称。一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性。当我们手动给Array对象添加了额外的属性后，<code>for … in</code>循环将带来意想不到的意外效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">const arr=[1,2,];</div><div class="line">arr.len = 3;</div><div class="line">for(let i in arr)&#123;</div><div class="line">    console.log(i + &apos;  &apos; + arr[i]);</div><div class="line">&#125;</div><div class="line">// 输出</div><div class="line">0  1</div><div class="line">1  2</div><div class="line">len  3</div></pre></td></tr></table></figure><p>而当我们使用 <code>for ... of</code> 时，它实际上是遍历的数组的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const arr=[1,2,];</div><div class="line">arr.len = 3;</div><div class="line">for(let i of arr)&#123;</div><div class="line">    console.log(i);</div><div class="line">&#125;</div><div class="line">// 输出</div><div class="line">1</div><div class="line">2</div></pre></td></tr></table></figure><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>该方法是ES5.1标准引入的。<strong>方法返回值为 <code>undefined</code> 并且不可链式调用，没有办法中止或者跳出    forEach 循环，除了抛出一个异常。</strong></p><p>该方法按升序为数组中含有效值的每一项执行一次 <code>callback</code> 函数，那些已删除（使用delete方法等情况）或者未初始化的项将被跳过（但不包括那些值为 <code>undefined</code> 的项）（例如在稀疏数组上）。</p><p><code>forEach</code> 遍历的范围在第一次调用 <code>callback</code> 前就会确定。调用 <code>forEach</code> 后添加到数组中的项不会被 <code>callback</code>访问到。如果已经存在的值被改变，则传递给 <code>callback</code> 的值是 <code>forEach</code> 遍历到他们那一刻的值。已删除的项不会被遍历到。如果已访问的元素在迭代时被删除了(例如使用 <code>shift()</code>) ，之后的元素将被跳过。</p><p>使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">array.forEach(callback(currentValue, index, array)&#123;</div><div class="line">    //do something</div><div class="line">&#125;, this)</div><div class="line"></div><div class="line">array.forEach(callback[, thisArg])</div><div class="line"></div><div class="line">callback</div><div class="line">为数组中每个元素执行的函数，该函数接收三个参数：</div><div class="line">currentValue(当前值)</div><div class="line">数组中正在处理的当前元素。</div><div class="line">index(索引)</div><div class="line">数组中正在处理的当前元素的索引。</div><div class="line">array</div><div class="line">forEach()方法正在操作的数组。</div><div class="line">thisArg（可选）</div><div class="line">可选参数。当执行回调函数时用作this的值(参考对象)。</div></pre></td></tr></table></figure><p>如果给<code>forEach</code>传递了<code>thisArg</code>参数，当调用时，它将被传给 <code>callback</code> 函数，作为它的this值。否则，将会传入 <code>undefined</code> 作为它的this值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const arr=[1,2,3];</div><div class="line">arr.forEach((v,i) =&gt; console.log( i + &apos;  &apos; + v ))</div><div class="line">// 输出</div><div class="line">0  1</div><div class="line">1  2</div><div class="line">2  3</div></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>该方法返回一个新数组，数组中每个元素都是调用提供的函数后返回的结果，<strong>原数组不变</strong>。</p><p>使用方法为（参数含义与 <code>forEach</code> 相似）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let array = arr.map(function callback(currentValue, index, array) &#123; </div><div class="line">    // Return element for new_array </div><div class="line">&#125;[, thisArg])</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var numbers = [1, 4, 9];</div><div class="line">var roots = numbers.map(Math.sqrt);</div><div class="line">// roots的值为[1, 2, 3], numbers的值仍为[1, 4, 9]</div></pre></td></tr></table></figure><p>该方法后续可以跟上数组其他方法，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var str = &apos;12345&apos;;</div><div class="line">Array.prototype.map.call(str, x =&gt; x).reverse().join(&apos;&apos;); </div><div class="line">// &quot;54321&quot;</div></pre></td></tr></table></figure><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>该方法对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值，并返回这个值。<strong>原数组不变</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arr.reduce(function (previous, current, index, arr) &#123; ... &#125;[, initialValue])</div></pre></td></tr></table></figure><p><code>callback</code> 函数接受4个参数：之前值、当前值、索引值以及数组本身。<code>initialValue</code>参数可选，表示初始值。若指定，则当作最初使用的<code>previous</code>值；如果缺省，则使用数组的第一个元素作为<code>previous</code>初始值，同时<code>current</code>往后排一位，相比有<code>initialValue</code>值少一次迭代。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let sum = [1, 2, 3, 4].reduce((previous, current, index, array) =&gt; previous + current); </div><div class="line">sum // 10</div></pre></td></tr></table></figure><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>返回经过过滤后的数组。<strong>原数组不变</strong>，用法与<code>forEach</code>相似。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">array.filter(callback,[ thisObject]);</div></pre></td></tr></table></figure><p><code>filter</code>的<code>callback</code>函数需要返回布尔值<code>true</code>或<code>false</code>。如果为<code>true</code>，则表示通过筛选；若为<code>false</code>，则会被过滤掉。返回值只需要弱等于<code>== true/false</code>就可以了，并非<code>=== true/false</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var data = [0, 1, 2, 3];</div><div class="line">data.filter(item =&gt; item &gt;= 2);</div><div class="line">// [2, 3]</div></pre></td></tr></table></figure><h3 id="some"><a href="#some" class="headerlink" title="some"></a>some</h3><p>该方法测试数组中的某些元素是否通过由提供的函数给出的条件。若某一项符合则返回<code>true</code>，否则返回<code>false</code>。<strong>原数组不变</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arr.some(callback[, thisArg])</div></pre></td></tr></table></figure><p><code>callback</code>函数需要返回值，只需要弱等于<code>== true/false</code>就可以了。我们自然可以使用<code>forEach</code>进行判断，不过，相比<code>some</code>, 不足在于，<code>some</code>只有有<code>true</code>即返回不再执行了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var scores = [5, 8, 3, 10];</div><div class="line">scores.some(item =&gt; item &gt; 8);</div><div class="line">// true</div></pre></td></tr></table></figure><h3 id="every"><a href="#every" class="headerlink" title="every"></a>every</h3><p>用法与<code>some</code>完全相似，区别在于<code>every</code>需要所有的元素都满足条件才会返回<code>true</code>，某一项不符合就会返回<code>false</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在平常的开发中，对数组这一数据结构的操作我们是避免不了的，对它的增、删、改、查等操作可以说是经常性的。在这些操作中，对数组的遍历可以说是再普通不过的事情了。然而就这一普通的操作也有很多的方法，平常我们用的也就那么一两种。&lt;/p&gt;
&lt;p&gt;为了更好的让我们记忆和选择这些方法来帮助我们提高开发效率，今天就把这些方法统一的罗列出来，方便以后查阅。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>页面滚动到某个元素</title>
    <link href="http://yoursite.com/2017/10/10/%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8%E5%88%B0%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2017/10/10/页面滚动到某个元素/</id>
    <published>2017-10-10T05:40:37.000Z</published>
    <updated>2017-10-13T07:24:21.739Z</updated>
    
    <content type="html"><![CDATA[<p>在某些应用场景中，需要我们点击某个地方把页面滚动到某处。通常我们会使用js去计算摇滚动到的地方距离页面顶部的距离，然后使用<code>document.scrollTop = xxx</code>来控制页面的滚动距离。</p><p>在页面结构比较简单的时候，这个距离比较好计算，但是当页面结构很复杂的时候，距离的计算就比较复杂了。</p><p>在Web API中存在两个很实用的方法可以快速帮我们实现这个需求，它们就是<code>scrollIntoView</code>与 <code>scrollIntoViewIfNeeded</code>。</p><a id="more"></a><h3 id="scrollIntoView"><a href="#scrollIntoView" class="headerlink" title="scrollIntoView"></a>scrollIntoView</h3><p>它的使用方法为<code>element.scrollIntoView()</code>，将不在浏览器窗口的可见区域内的元素滚动到浏览器窗口的可见区域。但是这个API在可见区域内的元素也是可以滚动的。</p><p>在说怎么使用之前，先来看看他的浏览器兼容性：<br><img src="/2017/10/10/页面滚动到某个元素/scrollIntoView.png" alt="scrollIntoView的兼容性" title="scrollIntoView的兼容性"></p><p>从图中可以看出兼容性一片良好，除了个别属性不支持外，基本上是可以放心的使用了。</p><p>它的参数有两种类型：Boolean类型和Object类型。</p><p>当参数为Boolean类型时：</p><ul><li>当为<code>true</code>时，元素的顶端将和其所在滚动区的可视区域的顶端对齐</li><li>当为<code>false</code>时，元素的底端将和其所在滚动区的可视区域的底端对齐</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const element = document.querySelector(selector);</div><div class="line">element.scrollIntoView(true);</div></pre></td></tr></table></figure><p>当参数为Object类型时：</p><ul><li>block字段与Boolean类型一样，取值为更加形象的 <code>start</code> 和 <code>end</code></li><li>behavior字段控制过渡的动画，取值为 <code>auto</code> 或 <code>instant</code> 或 <code>smooth</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    behavior: &quot;auto&quot;  | &quot;instant&quot; | &quot;smooth&quot;,</div><div class="line">    block:    &quot;start&quot; | &quot;end&quot;,</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>element.scrollIntoView(true)</code>与<code>element.scrollIntoView({block: &#39;start&#39;})</code>效果是一样的。</p><p>behavior字段控制过渡的动画，当取值为<code>auto</code>或<code>instant</code>时，效果都是一样的，页面会瞬间跳到指定的元素处。当取值为<code>smooth</code>时，页面会平滑的滚动到指定的元素处，但是除了Chrome和Firefox外其他浏览器不支持这个属性。</p><h3 id="scrollIntoViewIfNeeded"><a href="#scrollIntoViewIfNeeded" class="headerlink" title="scrollIntoViewIfNeeded"></a>scrollIntoViewIfNeeded</h3><p>使用方法与<code>scrollIntoView</code>API相同，也是将不在浏览器窗口的可见区域内的元素滚动到浏览器窗口的可见区域，但是元素在可见区域内该方法则不会有任何效果。</p><p>首先还是来看看它的兼容性是怎样：<br><img src="/2017/10/10/页面滚动到某个元素/scrollIntoViewIfNeeded.png" alt="scrollIntoViewIfNeeded的兼容性" title="scrollIntoViewIfNeeded的兼容性"></p><p>从图中可以看出这个API目前只有webkit内核的浏览器才支持。如果是在移动端，那就可以放心的使用了。</p><p>参数只有Boolean类型：</p><ul><li>当为<code>true</code>时，让元素在可视区域中居中对齐</li><li>当为<code>false</code>时，元素可能顶部或底部对齐，视乎元素靠哪一边更近</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const element = document.querySelector(selector);</div><div class="line">element.scrollIntoViewIfNeeded(true);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在某些应用场景中，需要我们点击某个地方把页面滚动到某处。通常我们会使用js去计算摇滚动到的地方距离页面顶部的距离，然后使用&lt;code&gt;document.scrollTop = xxx&lt;/code&gt;来控制页面的滚动距离。&lt;/p&gt;
&lt;p&gt;在页面结构比较简单的时候，这个距离比较好计算，但是当页面结构很复杂的时候，距离的计算就比较复杂了。&lt;/p&gt;
&lt;p&gt;在Web API中存在两个很实用的方法可以快速帮我们实现这个需求，它们就是&lt;code&gt;scrollIntoView&lt;/code&gt;与 &lt;code&gt;scrollIntoViewIfNeeded&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="HTML5" scheme="http://yoursite.com/categories/HTML5/"/>
    
      <category term="Web API" scheme="http://yoursite.com/categories/HTML5/Web-API/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="Web API" scheme="http://yoursite.com/tags/Web-API/"/>
    
  </entry>
  
</feed>
